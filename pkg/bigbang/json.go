package bigbang

import (
	"fmt"
	"io"
	"net/http"
	"strings"

	"github.com/karuppiah7890/go-jsonschema-generator"
	"gopkg.in/yaml.v2"
)

// Run pulls the values file for the provivded bigbang version and then
// iterates through the appropriate packages to pull the values file for each
// package.

// It then merges the values file in an appropriate manner to create an
// JSON Schema file
func Run(version string) error {
	// https://repo1.dso.mil/platform-one/big-bang/bigbang/-/raw/master/chart/values.yaml
	bb, err := get("https://repo1.dso.mil/platform-one/big-bang/bigbang", version)
	if err != nil {
		return err
	}
	values := make(map[string]interface{})

	// Parse the http body into a yaml structure
	// TODO pull out comments!
	err = yaml.Unmarshal(bb, &values)
	// s := &jsonschema.Document{}
	// s.ReadDeep(&values)
	// fmt.Println(s)

	//Istio...
	strings := make(map[string]map[string]map[string]interface{})
	err = yaml.Unmarshal(bb, &strings)
	nested := make(map[string]map[string]interface{})
	err = yaml.Unmarshal(bb, &nested)
	// Should be able to loop smartly on paths with git
	for p, top := range strings {
		for key, val := range top {
			if key == "git" {
				// found a git!
				repo := val["repo"].(string)
				tag := val["tag"].(string)
				// fmt.Printf("Getting %v@%v\n", repo, tag)
				b, err := get(repo, tag)
				if err != nil {
					// fmt.Printf("Error getting values from %v@%v: %v", repo, tag, err)
					return err
				}
				// fmt.Printf(string(ib))
				subValues := make(map[string]interface{})
				err = yaml.Unmarshal(b, &subValues)

				nested[p]["values"] = subValues
				// fmt.Printf("Added Values to %v\n", p)
			}
		}
	}

	//addons
	addons := make(map[string]map[string]map[string]map[string]interface{})
	err = yaml.Unmarshal(bb, &addons)
	for p, top := range addons["addons"] {
		for key, val := range top {
			if key == "git" {
				// found a git!
				// fmt.Printf("addons.%v.%v\n", p, key)
				repo := val["repo"].(string)
				tag := val["tag"].(string)
				// fmt.Printf("Getting %v@%v\n", repo, tag)
				b, err := get(repo, tag)
				if err != nil {
					// fmt.Printf("Error getting values from %v@%v: %v", repo, tag, err)
					return err
				}
				// fmt.Printf(string(ib))
				subValues := make(map[string]interface{})
				err = yaml.Unmarshal(b, &subValues)

				nested["addons"][p].(map[interface{}]interface{})["values"] = subValues
				// fmt.Printf("Added Values to %v\n", p)
			}
		}
	}
	// tag := strings["istio"]["git"]["tag"]
	// repo := strings["istio"]["git"]["repo"]
	// // istioVersion := values["istio"]["git"]["tag"]
	// // fmt.Printf("Istio Version: %v\n", tag)
	// // fmt.Println(string(b))

	// ib, err := get(repo.(string), tag.(string))
	// if err != nil {
	// 	return err
	// }
	// // fmt.Printf(string(ib))
	// istioValues := make(map[string]interface{})
	// err = yaml.Unmarshal(ib, &istioValues)

	// fmt.Println(i)

	//we want the top level istio properties injected into the
	// bigbang properties at .istio.values.properties....

	nestedDocument := &jsonschema.Document{}
	nestedDocument.ReadDeep(&nested)
	fmt.Println(nestedDocument)
	return nil

}

func get(baseURL, version string) ([]byte, error) {
	// https://repo1.dso.mil/platform-one/big-bang/bigbang/-/raw/master/chart/values.yaml
	// Some repos have a .git, so we trim that.
	bbUrl := fmt.Sprintf("%v/-/raw/%v/chart/values.yaml", strings.TrimSuffix(baseURL, ".git"), version)

	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go

	// curl https://repo1.dso.mil/platform-one/big-bang/bigbang/-/raw/master/chart/values.yaml

	resp, err := http.Get(bbUrl)
	if err != nil {
		// handle err
	}
	defer resp.Body.Close()

	return io.ReadAll(resp.Body)
}
